}
is.listed <- function(corpList, stockList) {
res <- lapply(corpList[[1]], function(x) {
a <- with(stockList, {stockList[FullName == x]})
if (nrow(a) == 0) {
a <- data.table(Ticker = 'noinfo', StockName = 'noinfo', Fullname = 'noinfo', Abbreviation = 'noinfo',
Exchange = 'noinfo')
} else if (nrow(a) > 1)
warning(paste(x, 'has more than one result, only first will be shown'))
return(a[1,])
})
resC <- rbindlist(res)
return(resC)
}
is.listed(a, data)
library(data.table)
is.listed(a, data)
is.listed <- function(corpList, stockList) {
res <- lapply(corpList[[1]], function(x) {
a <- with(stockList, {stockList[FullName == x]})
if (nrow(a) == 0) {
a <- data.table(Ticker = 'noinfo', StockName = 'noinfo', Fullname = 'noinfo', Abbreviation = 'noinfo',
Exchange = 'noinfo')
} else if (nrow(a) > 1)
warning(paste(x, 'has more than one result, only first will be shown'))
return(a[1,])
})
resC <- rbindlist(res)
# attach corpList to compare and double check
resC$input <- corpList
return(resC)
}
is.listed(a, data)
install.packages('shiny')
library(jsonlite)
library(httr)
statscnbase<-'http://data.stats.gov.cn/english/easyquery.htm'
rstatscnEnv<-new.env()
assign('prefix',NULL, envir=rstatscnEnv)
#' private function for sec
#'
#' @return milsec
milSec<-function()
{
tt=Sys.time()
ts=format(tt,"%s")
ts=paste(ts,"000",sep="")
ts
}
#' the available dbs
#'
#' the available dbs in the national db
#' @return a data frame with 2 columns , one is the dbcode, another is the db description
#' @export
#' @examples
#'  statscnDbs()
statscnDbs<-function()
{
dbs <- c("hgnd","hgjd","hgyd","fsnd","fsjd","fsyd","csnd","csyd","gjnd","gjyd","gjydsdj")
dbnames <- c("national data, yearly","national data,  quaterly","national data, monthly",
"province data, yearly","province data, quaterly","province data, monthly",
"city data, yearly","city data, monthly", "international data, yearly",
"international data, monthly","3 main countries data, monthly")
ret=data.frame(dbcode=dbs,description=dbnames)
return(ret)
}
#' private function for constructing the query parameter for dfwds
#'
#' @param wdcode string value , one of c("zb","sj","reg")
#' @param valuecode string value ,  following is the table for available valuecode
#'    zb:   the valudecode can be gotten by statscnQueryZb() function
#'    sj:   the valudecode can be "2014" for nd db,  "2014C" for jd db.
#'    reg:  the valudecode is the region code fetched by statscnRegions(dbcode) function
#' @return return the queyr string for the http request
genDfwds<-function(wdcode,valuecode)
{
if( is.na(valuecode) ){
return("[]")
}else{
paste('[{"wdcode":"',wdcode,'","valuecode":"',valuecode,'"}]',sep="")
}
}
#' private function for check the http status
#'
#' @param ret the response obj returned by httr package
#' @return return nothing , but if it finds some error , it stop the script
checkHttpStatus<-function(ret)
{
if (http_status(ret)$category != "Success") {
stop(sprintf("Bad response from %s", statscnbase))
}
}
#' private function to convert the returned jason data to a dataframe
#'
#' @param rawObj the fromJSON output
#' @param rowcode rowcode in the data frame
#' @param colcode colcode in the data frame
#' @return the contructed data frame
dataJson2df<-function(rawObj,rowcode,colcode)
{
ret=rawObj
if(ret[[1]] != 200) {
stop("Bad response from the statscn server")
}
#dataStructure
#jj is a list
#jj[[1]] = 200 #return code
#jj[[2]] is datanode
#jj[[2]][[1]] is data
#jj[[2]][[2]] is description
#jj[[2]][[2]][,"nodes"][[1]] is row description , it is a dataframe
#jj[[2]][[2]][,"nodes"][[2]] is col description , it is a dataframe
desList=ret[[2]][[2]][,'nodes']
rowWdIdx = which(ret[[2]][[2]]$wdcode == rowcode)
colWdIdx = which(ret[[2]][[2]]$wdcode == colcode)
rowDes=desList[[rowWdIdx]]
colDes=desList[[colWdIdx]]
rowNum=nrow(rowDes)
colNum=nrow(colDes)
rowNames=rowDes[,1]
colNames=colDes[,1]
units=rowDes[,'unit']
units=ifelse(units=="","",paste("(",units,")",sep=""))
rowNames=paste(rowNames,units,sep="")
prefix=get('prefix', envir=rstatscnEnv)
if(! is.null(prefix) ){
mrows=1:length(rowNames)
rowNames = paste(mrows,rowNames,sep=".")
}
rowCodes=rowDes[,2]
colCodes=colDes[,2]
#the rowCode and colCode are in the ret[[2]][[1]][,'wds']
#it is a list , the list length is the same as the data fetched. list[[1]] is for the first data
#list[[1]] is a dataframe ,  df[1,'valuecode'] is the rowcode , df[2,'valuecode'] is the colcode
#now we create a dataframe
myret=as.data.frame(matrix(rep(NA,rowNum*colNum),nrow=rowNum))
rownames(myret)=rowCodes
colnames(myret)=colCodes
dfdata=ret[[2]][[1]]
for (k in seq(1,nrow(dfdata))) {
wddf=dfdata[k,"wds"][[1]]
myret[wddf[rowWdIdx,'valuecode'],wddf[colWdIdx,'valuecode']] = dfdata[k,'data'][1,'data']
}
rownames(myret)=rowNames
colnames(myret)=colNames
return(myret)
}
#' the data categories
#'
#' the sub data categories for the zbid category, dbcode need to be specified, where the dbcode can be fetched by function
#' statscnDbs(). In the returned data frame, the column 'isParent' shows if each sub category is leap category or not
#' @param zbid the father zb/category id , the root id is 'zb'
#' @param dbcode which db will be queried
#' @return the data frame with the sub zbs/categories , if the given zbid is not a Parent zb/category, null list is returned
#' @export
#' @examples
#'  statscnQueryZb()
#'  statscnQueryZb('A01',dbcode="hgnd")
statscnQueryZb<-function(zbid="zb",dbcode="hgnd")
{
curQuery=list(id=zbid,dbcode=dbcode,wdcode="zb",m="getTree")
yy<-POST(statscnbase,body=curQuery,encode="form")
assign('lastQuery',curQuery, envir=rstatscnEnv)
checkHttpStatus(yy)
jj=fromJSON(content(yy,"text",encoding="utf-8"))
return(jj)
}
#' the regions in db
#'
#' the available regions in the specified db, it is used for query the province, city and country code generally
#' @param dbcode the dbcode should be some province db(fs*) , city db(cs*) or internaltional db(gj*)
#' @return the data frame with all the available region codes and names in the db
#' @export
#' @examples
#'  statscnRegions('fsnd')
#'  statscnRegions('csnd')
#'  statscnRegions('gjnd')
statscnRegions<-function(dbcode='fsnd')
{
curQuery<-list(
m="getOtherWds",
dbcode=dbcode,
rowcode="zb",
colcode="sj",
wds="[]",
#dfwds="[]",
k1=milSec()
)
yy<-GET(statscnbase, query=curQuery)
assign('lastQuery',curQuery, envir=rstatscnEnv)
checkHttpStatus(yy)
ret=fromJSON(content(yy,"text",encoding="utf-8"))
regIndex <- which(ret[[2]]$wdcode == 'reg')
df <- ret[[2]][,'nodes'][[regIndex]]
df$sort=NULL
colnames(df) <- c("regCode","name")
return(df)
}
#' query data in the statscn db
#'
#' the main function for querying the statscn database, it will retrieve the data from specified db and orginize the data in a data frame.
#' @param zb the zb/category code to be queried
#' @param dbcode the db code for querying
#' @param rowcode rowcode in the returned data frame
#' @param colcode colcode in the returned data frame
#' @param moreWd more constraint on the data
#'        where the name should be one of c("reg","sj") , which stand for region and sj/time.
#'        the valuecode for reg should be the region code queried by statscnRegions()
#'        the valuecode for sj should be like '2014' for *nd , '2014C' for *jd , '201405' for *yd.
#'        Be noted that , the moreWd name should be different with either rowcode or colcode
#' @return the data frame you are quering
#' @export
#' @examples
#' df=statscnQueryData('A0201',dbcode='hgnd')
#' df=statscnQueryData('A0201',dbcode='fsnd',rowcode='zb',colcode='sj',
#'                     moreWd=list(name='reg',value='110000'))
statscnQueryData<-function(zb="A0201",dbcode="hgnd",rowcode='zb',colcode='sj',moreWd=list(name=NA,value=NA))
{
curQuery<-list(
m="QueryData",
dbcode=dbcode,
rowcode=rowcode,
colcode=colcode,
wds=genDfwds(moreWd$name,moreWd$value),
dfwds=genDfwds("zb",zb),
k1=milSec()
)
yy<-GET(statscnbase, query=curQuery)
assign('lastQuery',curQuery, envir=rstatscnEnv)
checkHttpStatus(yy)
ret=fromJSON(content(yy,"text",encoding="utf-8"))
return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))
}
#' fetch the lastN data
#'
#' fetch the lastN data for the latest query, only affect the number of rows in the returned data.
#' This function can not be used alone , statscnQueryData() has to be called before this function
#' @param n the number of rows to be fetched
#' @return the last n rows data in the latest query
#' @export
#' @examples
#' df=statscnQueryData('A0201',dbcode='hgnd')
#' df2=statscnQueryLastN(20)
statscnQueryLastN<-function(n)
{
wdcode="sj"
valuecode=paste("LAST",n,sep="")
if( is.null(get('lastQuery', envir=rstatscnEnv)) ){
stop("please call a statscnQueryData for some data firstly")
}
curQuery=get('lastQuery', envir=rstatscnEnv)
if( curQuery$m=="QueryData" ) {
curQuery$dfwds=genDfwds(wdcode,valuecode)
}
yy<-GET(statscnbase, query=curQuery)
assign('lastQuery',curQuery, envir=rstatscnEnv)
checkHttpStatus(yy)
ret=fromJSON(content(yy,"text",encoding="utf-8"))
return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))
}
#' statscnRowNamePrefix
#'
#' set the rowName prefix in the dataframe
#'
#' in case you encounter the following error:
#'   Error in `row.names<-.data.frame`(`*tmp*`, value = value) :
#'   duplicate 'row.names' are not allowed
#' you need to call this function
#'
#' @param p , how to set the rowname prefix.
#'     it is 'nrow' by default , and it is the only supported value currently
#'     to unset the row name prefix, call this function with p=NULL
#' @return no return
#' @export
statscnRowNamePrefix<-function(p="nrow")
{
if (p != "nrow" && ! is.null(p)) {
stop(sprintf("the only supported prefix is 'nrow' or NULL "))
}
assign('prefix',p, envir=rstatscnEnv)
}
statscnDbs()
statscnQueryZb(dbcode='hgnd')
statscnQueryZb('A01',dbcode='hgnd')
?http_status
??http_status
devtools::check()
?devtools::check()
?devtools::check(asCran = T)
?devtools::check(as.cran = T)
devtools::check(cran = T)
devtools::check(cran = T)
library(gfer)
df <- statscnQueryData('A0201', dbcode = 'hgnd')
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
moreWd = list(name = 'reg', value = '110000'))
debug(statscnQueryData)
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
moreWd = list(name = 'reg', value = '110000'))
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
n
undebug(statscnQueryData)
debug(dataJson2df)
?dataJson2df
debug(gfer::dataJson2df)
debug(statscnQueryData)
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
moreWd = list(name = 'reg', value = '110000'))
debug(dataJson2df)
rowCodes
rownames(myret)
myret
myret
rowNames
rownames(myret)
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
moreWd = list(name = 'reg', value = '110000'))
rownames(myret)
rownames(myret) <- rowNames
rowNames
rownames(myret)
df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',
moreWd = list(name = 'reg', value = '110000'))
curQuery
ret
content(yy, "text", encoding = "utf-8")
fromJSON(content(yy, "text", encoding = "utf-8"))
statscnQueryZb('A01',dbcode='fsnd')
statscnQueryZb('A0102',dbcode='fsnd')
statscnQueryZb('A02',dbcode='fsnd')
statscnQueryZb('A0201',dbcode='fsnd')
devtools::check(cran = T)
devtools::check(cran = T)
devtools::check(cran = T)
reference(rstatscn)
cite(rstatscn)
citation
citation()
citation("rstatscn")
devtools::document()
devtools::check(cran = T)
devtools::build()
devtools::
devtools::check(cran = T)
statscnQueryZb('A02', dbcode = 'fsnd')
statscnQueryZb('A0201', dbcode = 'fsnd')
statscnQueryZb('A02', dbcode = 'fsnd')
statscnQueryData('A0201', dbcode = 'fsnd')
a <- statscnQueryData('A0201', dbcode = 'fsnd')
str(a)
a <- statscnQueryData('A0201', dbcode = 'fsnd', rowcode = 'reg')
a
statscnQueryData('A0201', dbcode = 'fsnd')
statscnQueryData('A0201')
devtools::check(cran = T)
devtools::build()
devtools::check(cran = T)
devtools::build()
devtools::document()
devtools::check(cran = T)
devtools::build()
devtools::document()
getPPPList(1,3)
devtools::check(cran = T)
getPPPList(1,3)
?rbindlist
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(A=4:5,B=letters[4:5])
l = list(DT1,DT2)
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(A=4:5,B=letters[4:5])
l = list(DT1,DT2)
DT1 = data.table(A=1:3,B=letters[1:3])
library(data.table)
DT1 = data.table(A=1:3,B=letters[1:3])
DT2 = data.table(A=4:5,B=letters[4:5])
rbindlist(DT1, DT2)
DT1
DT2
l = list(DT1,DT2)
l = list(DT1,DT2)
devtools::check(cran = T)
getPPPList(1,3)
getTickers('中国神华股份有限公司')
library(gfer)
library(gfer)
getTickers('中国神华股份有限公司')
indexData <- getIndexData()
getIndex('600601', indexData)
getIndex('60060', indexData)
getIndex('600100', indexData)
GDP <- statscnQueryData('A0201', dbcode = 'fsnd')
library(gfer)
library(gfer)
library(gfer)
GDP <- statscnQueryData('A0201', dbcode = 'fsnd')
devtools::check(cran = T)
GDP <- statscnQueryData('A0201', dbcode = 'fsnd')
GDP
GDP <- statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value='2015'))
GDP
GDP_total <- lapply(2013:2015, function(x) statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value=x)))
str(GDP_total)
GDP_total <- lapply(2013:2015, function(x) {
a <- statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value=x))
a$Year <- x
return(a)
})
str(GDP_total)
str(GDP_total[[1]])
GDP_total[[1]]
GDP <- lapply(2013:2015, function(x) {
a <- statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
library(data.table)
GDP_total <- rbindlist(GDP)
str(GDP_total)
GDP_total
?rbind
dataForCWR <- function(indicator, start, end) {
switch(indicator,
'GDP' = 'A0201')
GDP <- lapply(start:end, function(x) {
a <- statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
return(GDP_total)
}
getBasicData_CWR <- function(indicator, start, end) {
switch(indicator,
'GDP' = 'A0201')
GDP <- lapply(start:end, function(x) {
a <- statscnQueryData('A0201',dbcode='fsnd',rowcode='reg',colcode='zb',moreWd=list((name='sj'),value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
return(GDP_total)
}
GDP_total <- getBasicData_CWR('GDP', 2013, 2015)
GDP_total
str(GDP_total)
statscnQueryZb(dbcode='fsnd')
statscnQueryZb('A0C',dbcode='hgnd')
GDP_total <- getBasicData_CWR('wastewater', 2013, 2015)
GDP_total
str(GDP_total)
getBasicData_CWR <- function(indicator, start, end) {
switch(indicator,
'GDP' = 'A0201',
'water resources' = 'A0C02',
'water use' = 'A0C03',
'wastewater' = 'A0C04')
GDP <- lapply(start:end, function(x) {
a <- statscnQueryData(indicator, dbcode='fsnd', rowcode='reg', colcode='zb', moreWd=list((name='sj'), value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
return(GDP_total)
}
GDP_total <- getBasicData_CWR('wastewater', 2013, 2015)
debug(GDP_total)
debug(GgetBasicData_CWR)
debug(getBasicData_CWR)
GDP_total <- getBasicData_CWR('wastewater', 2013, 2015)
indicator
getBasicData_CWR <- function(indicator, start, end) {
index <- switch(indicator,
'GDP' = 'A0201',
'water resources' = 'A0C02',
'water use' = 'A0C03',
'wastewater' = 'A0C04')
GDP <- lapply(start:end, function(x) {
a <- statscnQueryData(index, dbcode='fsnd', rowcode='reg', colcode='zb', moreWd=list((name='sj'), value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
return(GDP_total)
}
GDP_total <- getBasicData_CWR('wastewater', 2013, 2015)
str(GDP_total)
statscnQueryZb('A0C',dbcode='hgnd')
statscnQueryZb('A0C',dbcode='fsnd')
getBasicData_CWR <- function(indicator, start, end) {
index <- switch(indicator,
'GDP' = 'A0201',
'water resources' = 'A0C03',
'water use' = 'A0C04',
'wastewater' = 'A0C05')
GDP <- lapply(start:end, function(x) {
a <- statscnQueryData(index, dbcode='fsnd', rowcode='reg', colcode='zb', moreWd=list((name='sj'), value=x))
a$Year <- x
return(a)
})
GDP_total <- rbindlist(GDP)
return(GDP_total)
}
GDP_total <- getBasicData_CWR('wastewater', 2013, 2015)
str(GDP_total)
rm(list())
rm()
rm(list = ls())
devtools::document()
devtools::check(cran = T)
devtools::document()
