{
    "collab_server" : "",
    "contents" : "#library(jsonlite)\n#library(httr)\n\n# the code below sources from http://www.bagualu.net/wordpress/rstatscn-the-r-interface-for-china-national-data,\n# thanks to the author Jinag Hang\n# Because the above package only provides Chinese version, so I made a small change to the statscnbase link,\n# changed it to EN version.\n# The original and modified code below are under lisence Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n\n\n\nstatscnbase <- 'http://data.stats.gov.cn/english/easyquery.htm'\nrstatscnEnv <- new.env()\n# prefix also can be NULL, if it is a Chinese version.\n# change it to nrow mainly because in English version there could be duplicated row names\n#\nassign('prefix', 'nrow', envir=rstatscnEnv)\n\n\n#' private function for sec\n#'\n#' @return milsec\nmilSec <- function()\n{\n  tt <- Sys.time()\n  ts <- format(tt,\"%s\")\n  ts <- paste(ts,\"000\",sep = \"\")\n  ts\n}\n\n#' the available dbs\n#'\n#' the available dbs in the national db\n#' @return a data frame with 2 columns , one is the dbcode, another is the db description\n#' @export\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @examples\n#'  \\dontrun{\n#'  statscnDbs()\n#'  }\n#'\nstatscnDbs <- function()\n{\n  dbs <- c(\"hgnd\",\"hgjd\",\"hgyd\",\"fsnd\",\"fsjd\",\"fsyd\",\"csnd\",\"csyd\",\"gjnd\",\"gjyd\",\"gjydsdj\")\n  dbnames <- c(\"national data, yearly\",\"national data,  quaterly\",\"national data, monthly\",\n               \"province data, yearly\",\"province data, quaterly\",\"province data, monthly\",\n               \"city data, yearly\",\"city data, monthly\", \"international data, yearly\",\n               \"international data, monthly\",\"3 main countries data, monthly\")\n  ret <- data.frame(dbcode = dbs, description = dbnames)\n  return(ret)\n}\n\n#' private function for constructing the query parameter for dfwds\n#'\n#' @param wdcode string value , one of c(\"zb\",\"sj\",\"reg\")\n#' @param valuecode string value ,  following is the table for available valuecode\n#'    zb:   the valudecode can be gotten by statscnQueryZb() function\n#'    sj:   the valudecode can be \"2014\" for nd db,  \"2014C\" for jd db.\n#'    reg:  the valudecode is the region code fetched by statscnRegions(dbcode) function\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @return return the queyr string for the http request\ngenDfwds <- function(wdcode,valuecode)\n{\n  if( is.na(valuecode) ){\n    return(\"[]\")\n  }else{\n    paste('[{\"wdcode\":\"',wdcode,'\",\"valuecode\":\"',valuecode,'\"}]',sep = \"\")\n  }\n}\n#' private function for check the http status\n#'\n#' @param ret the response obj returned by httr package\n#' @importFrom httr http_status\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @return return nothing , but if it finds some error , it stop the script\ncheckHttpStatus <- function(ret)\n{\n  if (http_status(ret)$category != \"Success\") {\n    stop(sprintf(\"Bad response from %s\", statscnbase))\n  }\n}\n#' private function to convert the returned jason data to a dataframe\n#'\n#' @param rawObj the fromJSON output\n#' @param rowcode rowcode in the data frame\n#' @param colcode colcode in the data frame\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @return the contructed data frame\ndataJson2df <- function(rawObj,rowcode,colcode)\n{\n  ret <- rawObj\n  if(ret[[1]] != 200) {\n    stop(\"Bad response from the statscn server\")\n  }\n  #dataStructure\n  #jj is a list\n  #jj[[1]] = 200 #return code\n  #jj[[2]] is datanode\n  #jj[[2]][[1]] is data\n  #jj[[2]][[2]] is description\n  #jj[[2]][[2]][,\"nodes\"][[1]] is row description , it is a dataframe\n  #jj[[2]][[2]][,\"nodes\"][[2]] is col description , it is a dataframe\n  desList <- ret[[2]][[2]][,'nodes']\n  rowWdIdx <-  which(ret[[2]][[2]]$wdcode == rowcode)\n  colWdIdx <- which(ret[[2]][[2]]$wdcode == colcode)\n  rowDes <- desList[[rowWdIdx]]\n  colDes <- desList[[colWdIdx]]\n\n  rowNum <- nrow(rowDes)\n  colNum <- nrow(colDes)\n  rowNames <- rowDes[,1]\n  colNames <- colDes[,1]\n\n  units <- rowDes[,'unit']\n  units <- ifelse(units == \"\", \"\", paste(\"(\", units, \")\", sep = \"\"))\n  rowNames <- paste(rowNames, units, sep = \"\")\n\n  prefix <- get('prefix', envir = rstatscnEnv)\n  if(! is.null(prefix) ){\n    mrows <- 1:length(rowNames)\n    rowNames  <-  paste(mrows,rowNames,sep = \".\")\n  }\n\n  rowCodes <- rowDes[,2]\n  colCodes <- colDes[,2]\n\n  #the rowCode and colCode are in the ret[[2]][[1]][,'wds']\n  #it is a list , the list length is the same as the data fetched. list[[1]] is for the first data\n  #list[[1]] is a dataframe ,  df[1,'valuecode'] is the rowcode , df[2,'valuecode'] is the colcode\n  #now we create a dataframe\n  myret <- as.data.frame(matrix(rep(NA,rowNum*colNum),nrow = rowNum))\n  rownames(myret) <- rowCodes\n  colnames(myret) <- colCodes\n  dfdata <- ret[[2]][[1]]\n  for (k in seq(1,nrow(dfdata))) {\n    wddf <- dfdata[k,\"wds\"][[1]]\n    myret[wddf[rowWdIdx,'valuecode'],wddf[colWdIdx,'valuecode']] <- dfdata[k,'data'][1,'data']\n  }\n  rownames(myret) <- rowNames\n  colnames(myret) <- colNames\n  return(myret)\n}\n\n#' the data categories\n#'\n#' the sub data categories for the zbid category, dbcode need to be specified, where the dbcode can be fetched by function\n#' statscnDbs(). In the returned data frame, the column 'isParent' shows if each sub category is leap category or not\n#' @param zbid the father zb/category id , the root id is 'zb'\n#' @param dbcode which db will be queried\n#' @return the data frame with the sub zbs/categories , if the given zbid is not a Parent zb/category, null list is returned\n#' @importFrom httr POST\n#' @importFrom jsonlite fromJSON\n#' @export\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @examples\n#' \\dontrun{\n#' statscnQueryZb()\n#' statscnQueryZb('A01',dbcode=\"hgnd\")\n#' }\n#'\n#'\nstatscnQueryZb<-function(zbid = \"zb\",dbcode = \"hgnd\")\n{\n  curQuery <- list(id = zbid, dbcode = dbcode, wdcode = \"zb\", m = \"getTree\")\n  yy <- POST(statscnbase, body = curQuery, encode = \"form\")\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  jj <- fromJSON(content(yy, \"text\", encoding = \"utf-8\"))\n  return(jj)\n}\n#' the regions in db\n#'\n#' the available regions in the specified db, it is used for query the province, city and country code generally\n#' @param dbcode the dbcode should be some province db(fs*) , city db(cs*) or internaltional db(gj*)\n#' @return the data frame with all the available region codes and names in the db\n#' @importFrom jsonlite fromJSON\n#' @export\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @examples\n#' \\dontrun{\n#' statscnRegions('fsnd')\n#' statscnRegions('csnd')\n#' statscnRegions('gjnd')\n#' }\n#'\n#'\n#'\nstatscnRegions<-function(dbcode='fsnd')\n{\n  curQuery<-list(\n    m = \"getOtherWds\",\n    dbcode = dbcode,\n    rowcode = \"zb\",\n    colcode = \"sj\",\n    wds = \"[]\",\n    #dfwds=\"[]\",\n    k1 = milSec()\n  )\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy,\"text\",encoding = \"utf-8\"))\n  regIndex <- which(ret[[2]]$wdcode == 'reg')\n  df <- ret[[2]][,'nodes'][[regIndex]]\n  df$sort <- NULL\n  colnames(df) <- c(\"regCode\",\"name\")\n  return(df)\n}\n#' query data in the statscn db\n#'\n#' the main function for querying the statscn database, it will retrieve the data from specified db and orginize the data in a data frame.\n#' @param zb the zb/category code to be queried\n#' @param dbcode the db code for querying\n#' @param rowcode rowcode in the returned data frame\n#' @param colcode colcode in the returned data frame\n#' @param moreWd more constraint on the data\n#'        where the name should be one of c(\"reg\",\"sj\") , which stand for region and sj/time.\n#'        the valuecode for reg should be the region code queried by statscnRegions()\n#'        the valuecode for sj should be like '2014' for *nd , '2014C' for *jd , '201405' for *yd.\n#'        Be noted that , the moreWd name should be different with either rowcode or colcode\n#' @importFrom httr GET\n#' @importFrom jsonlite fromJSON\n#' @return the data frame you are quering\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @export\n#' @examples\n#'\n#' \\dontrun{\n#' df <- statscnQueryData('A0201', dbcode = 'hgnd')\n#' df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',\n#'                     moreWd = list(name = 'reg', value = '110000'))\n#' }\n#'\n#'\nstatscnQueryData <- function(zb = \"A0201\", dbcode = \"hgnd\", rowcode = 'zb', colcode = 'sj', moreWd = list(name = NA, value = NA))\n{\n  curQuery <- list(\n    m = \"QueryData\",\n    dbcode = dbcode,\n    rowcode = rowcode,\n    colcode = colcode,\n    wds = genDfwds(moreWd$name,moreWd$value),\n    dfwds = genDfwds(\"zb\",zb),\n    k1 = milSec()\n  )\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy,\"text\", encoding = \"utf-8\"))\n  return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))\n}\n#' fetch the lastN data\n#'\n#' fetch the lastN data for the latest query, only affect the number of rows in the returned data.\n#' This function can not be used alone , statscnQueryData() has to be called before this function\n#' @param n the number of rows to be fetched\n#' @return the last n rows data in the latest query\n#' @importFrom httr GET\n#' @importFrom jsonlite fromJSON\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @export\n#' @examples\n#' \\dontrun{\n#' df=statscnQueryData('A0201',dbcode='hgnd')\n#' df2=statscnQueryLastN(20)\n#' }\n#'\n#'\nstatscnQueryLastN<-function(n)\n{\n  wdcode <- \"sj\"\n  valuecode <- paste(\"LAST\",n,sep = \"\")\n  if( is.null(get('lastQuery', envir = rstatscnEnv)) ){\n    stop(\"please call a statscnQueryData for some data firstly\")\n  }\n  curQuery <- get('lastQuery', envir = rstatscnEnv)\n  if( curQuery$m==\"QueryData\" ) {\n    curQuery$dfwds <- genDfwds(wdcode,valuecode)\n  }\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy, \"text\", encoding = \"utf-8\"))\n  return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))\n}\n\n#' statscnRowNamePrefix\n#'\n#' set the rowName prefix in the dataframe\n#'\n#' in case you encounter the following error:\n#'   Error in `row.names<-.data.frame`(`*tmp*`, value = value) :\n#'   duplicate 'row.names' are not allowed\n#' you need to call this function\n#'\n#' @param p , how to set the rowname prefix.\n#'     it is 'nrow' by default , and it is the only supported value currently\n#'     to unset the row name prefix, call this function with p=NULL\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @return no return\n#' @export\nstatscnRowNamePrefix <- function(p = \"nrow\")\n{\n  if (p != \"nrow\" && ! is.null(p)) {\n    stop(sprintf(\"the only supported prefix is 'nrow' or NULL \"))\n  }\n  assign('prefix', p, envir = rstatscnEnv)\n}\n\n\n\n\n#' getNBS\n#'\n#' get National Bureau of Statistics data\n#'\n#' @param start starting year of data wanted\n#' @param end end year of data wanted, make sure your input end year exists in the NBS website\n#' @param indicator of which data is fetched, indicator includes 'GDP', 'water resources', 'water use' and 'wastewater', etc.\n#' @importFrom data.table rbindlist setcolorder\n#' @references\n#' Xuehui YANG (2016). rstatscn: R Interface for China National Data. R\n#' package version 1.1.1. https://CRAN.R-project.org/package=rstatscn\n#' @return no return\n#' @export\n\ngetNBS <- function(indicator, start, end) {\n  index <- switch(indicator,\n                  'GDP' = 'A0201',\n                  'water resources' = 'A0C03',\n                  'water use' = 'A0C04',\n                  'wastewater' = 'A0C05')\n  GDP <- lapply(start:end, function(x) {\n    a <- statscnQueryData(index, dbcode='fsnd', rowcode='reg', colcode='zb', moreWd=list(name='sj', value=x))\n    a$Year <- x\n    a$Province <- rownames(a)\n    return(a)\n  })\n\n  GDP_total <- rbindlist(GDP)\n\n  # re-order columns\n  n1 <- ncol(GDP_total)\n  newOrder <- c(n1, n1-1, 1:(n1-2))\n  setcolorder(GDP_total, newOrder)\n\n  # change province names\n\n  col <- sapply(GDP_total$Province, function(x) strsplit(x, '\\\\.')[[1]][2])\n  names(col) <- NULL\n  GDP_total$Province <- col\n  return(GDP_total)\n}\n\n\n#' updateNBS\n#'\n#' update/create the database in your google sheet. You have to sign in mannually for your google sheet\n#' Once finished, there will be a google sheet called NBS_data created in your google drive as database.\n#' @param start starting year of data wanted\n#' @param end end year of data wanted, make sure your input end year exists in the NBS website\n#' @import googlesheets\n#' @export\nupdateNBS <- function(start, end) {\n  message('Loading from NBS')\n  GDP <- getNBS('GDP', start, end)\n  wateruse <- getNBS('water use', start, end)\n  wastewater <- getNBS('wastewater', start, end)\n\n  #check if there are existing data base in the drive\n  message('Uploading to Google Sheet. It may take minites depending on data size.')\n  if (!'NBS_data' %in% gs_ls()[['sheet_title']]) {\n    gs_new('NBS_data', ws_title = 'GDP', input = GDP, trim = TRUE, verbose = TRUE)\n\n    gs_ws_new(gs_title('NBS_data'), ws_title = 'Water_use', trim = TRUE, verbose = TRUE)\n    gs_ws_new(gs_title('NBS_data'), ws_title = 'Wastewater')\n\n  } else {\n    gs_edit_cells(gs_title('NBS_data'), ws = 'GDP', input = GDP, trim = TRUE, verbose = TRUE)\n  }\n  sheet <- gs_title('NBS_data')\n\n  message('GDP upload finished.')\n  gs_edit_cells(sheet, ws = 'Water_use', input = wateruse, trim = TRUE, verbose = TRUE)\n  message('water use upload finished.')\n  gs_edit_cells(sheet, ws = 'Wastewater', input = wastewater, trim = TRUE, verbose = TRUE)\n  message('Wastewater upload finished.')\n  message('All finished')\n}\n\n#' getWaternomicsData\n#'\n#' Get NBS data from google sheet by shared link. Default link is provided by gfer, you can also create your\n#' own google sheet of GDP.\n#' NOTE: The 'link sharing on' of the sheet must be ticked in order to read\n#' @param start starting year of data wanted\n#' @param end end year of data wanted, make sure your input end year exists in the NBS website\n#' @importFrom gsheet gsheet2tbl\n#' @import data.table\n#' @export\n\ngetWaternomicsData <- function(start, end) {\n  message('Loading from NBS')\n  GDP <- getNBS('GDP', start, end)\n  wateruse <- getNBS('water use', start, end)\n  wastewater <- getNBS('wastewater', start, end)\n  closeAllConnections()\n\n\n  selected <- c('Province', 'Year','Gross Regional Product', 'Value-added of the Primary Industry', 'Value-added of the Secondary Industry',\n                'Value-added of the Tertiary Industry')\n  GDP <- GDP[, selected, with = F]\n\n  selected <- c('Province', 'Year', 'Total Use of Water')\n  wateruse <- wateruse[, selected, with = F]\n\n  selected <- c('Province', 'Year', 'Total Waste Water Discharged')\n  wastewater <- wastewater[, selected, with = F]\n\n  res <- cbind(GDP, wateruse[, 3], wastewater[,3])\n\n  # calculate x and y coordinates\n\n  res$x <- res[, 8]/res[, 3]\n  res$y <- res[, 7]/res[, 3]*10000\n  res$r <- res[, 3]\n\n\n  colnames(res)[1] <- 'label'\n\n\n\n  # need further development\n  return(res)\n}\n\n\n\n\n\n\n\n# @param province choose one or some provinces you are interested. Be careful you\n# have to type in the right name as below, e.g., it's 'Inner Mongolia', not 'Neimenggu':\n#\n# province: 'Beijing', 'Tianjin', 'Hebei', 'Shanxi', 'Inner Mongolia', 'Liaoning',\n# 'Jilin', 'Heilongjiang', 'Shanghai', 'Jiangsu', 'Zhejiang', 'Anhui', 'Fujian', 'Jiangxi',\n# 'Shandong', 'Henan', 'Hubei', 'Hunan', 'Guangdong', 'Guangxi', 'Hainan', 'Chongqing',\n# 'Sichuan', 'Guizhou', 'Yunnan', 'Tibet', 'Shaanxi', 'Gansu', 'Qinghai', 'Ningxia', 'Xinjiang'\n\n\n",
    "created" : 1502593949246.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "909540132",
    "id" : "9734E557",
    "lastKnownWriteTime" : 1502601618,
    "last_content_update" : 1502601618231,
    "path" : "~/GitHub/gfer/R/getNBS.R",
    "project_path" : "R/getNBS.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}