{
    "collab_server" : "",
    "contents" : "#library(jsonlite)\n#library(httr)\n\n\nstatscnbase <- 'http://data.stats.gov.cn/english/easyquery.htm'\nrstatscnEnv <- new.env()\n# prefix also can be NULL, if it is a Chinese version.\n# change it to nrow mainly because in English version there could be duplicated row names\n#\nassign('prefix', 'nrow', envir=rstatscnEnv)\n\n\n#' private function for sec\n#'\n#' @return milsec\nmilSec <- function()\n{\n  tt <- Sys.time()\n  ts <- format(tt,\"%s\")\n  ts <- paste(ts,\"000\",sep = \"\")\n  ts\n}\n\n#' the available dbs\n#'\n#' the available dbs in the national db\n#' @return a data frame with 2 columns , one is the dbcode, another is the db description\n#' @export\n#' @examples\n#'  statscnDbs()\nstatscnDbs <- function()\n{\n  dbs <- c(\"hgnd\",\"hgjd\",\"hgyd\",\"fsnd\",\"fsjd\",\"fsyd\",\"csnd\",\"csyd\",\"gjnd\",\"gjyd\",\"gjydsdj\")\n  dbnames <- c(\"national data, yearly\",\"national data,  quaterly\",\"national data, monthly\",\n               \"province data, yearly\",\"province data, quaterly\",\"province data, monthly\",\n               \"city data, yearly\",\"city data, monthly\", \"international data, yearly\",\n               \"international data, monthly\",\"3 main countries data, monthly\")\n  ret <- data.frame(dbcode = dbs, description = dbnames)\n  return(ret)\n}\n\n#' private function for constructing the query parameter for dfwds\n#'\n#' @param wdcode string value , one of c(\"zb\",\"sj\",\"reg\")\n#' @param valuecode string value ,  following is the table for available valuecode\n#'    zb:   the valudecode can be gotten by statscnQueryZb() function\n#'    sj:   the valudecode can be \"2014\" for nd db,  \"2014C\" for jd db.\n#'    reg:  the valudecode is the region code fetched by statscnRegions(dbcode) function\n#' @return return the queyr string for the http request\ngenDfwds <- function(wdcode,valuecode)\n{\n  if( is.na(valuecode) ){\n    return(\"[]\")\n  }else{\n    paste('[{\"wdcode\":\"',wdcode,'\",\"valuecode\":\"',valuecode,'\"}]',sep = \"\")\n  }\n}\n#' private function for check the http status\n#'\n#' @param ret the response obj returned by httr package\n#' @importFrom httr http_status\n#' @return return nothing , but if it finds some error , it stop the script\ncheckHttpStatus <- function(ret)\n{\n  if (http_status(ret)$category != \"Success\") {\n    stop(sprintf(\"Bad response from %s\", statscnbase))\n  }\n}\n#' private function to convert the returned jason data to a dataframe\n#'\n#' @param rawObj the fromJSON output\n#' @param rowcode rowcode in the data frame\n#' @param colcode colcode in the data frame\n#' @return the contructed data frame\ndataJson2df <- function(rawObj,rowcode,colcode)\n{\n  ret <- rawObj\n  if(ret[[1]] != 200) {\n    stop(\"Bad response from the statscn server\")\n  }\n  #dataStructure\n  #jj is a list\n  #jj[[1]] = 200 #return code\n  #jj[[2]] is datanode\n  #jj[[2]][[1]] is data\n  #jj[[2]][[2]] is description\n  #jj[[2]][[2]][,\"nodes\"][[1]] is row description , it is a dataframe\n  #jj[[2]][[2]][,\"nodes\"][[2]] is col description , it is a dataframe\n  desList <- ret[[2]][[2]][,'nodes']\n  rowWdIdx <-  which(ret[[2]][[2]]$wdcode == rowcode)\n  colWdIdx <- which(ret[[2]][[2]]$wdcode == colcode)\n  rowDes <- desList[[rowWdIdx]]\n  colDes <- desList[[colWdIdx]]\n\n  rowNum <- nrow(rowDes)\n  colNum <- nrow(colDes)\n  rowNames <- rowDes[,1]\n  colNames <- colDes[,1]\n\n  units <- rowDes[,'unit']\n  units <- ifelse(units == \"\", \"\", paste(\"(\", units, \")\", sep = \"\"))\n  rowNames <- paste(rowNames, units, sep = \"\")\n\n  prefix <- get('prefix', envir = rstatscnEnv)\n  if(! is.null(prefix) ){\n    mrows <- 1:length(rowNames)\n    rowNames  <-  paste(mrows,rowNames,sep = \".\")\n  }\n\n  rowCodes <- rowDes[,2]\n  colCodes <- colDes[,2]\n\n  #the rowCode and colCode are in the ret[[2]][[1]][,'wds']\n  #it is a list , the list length is the same as the data fetched. list[[1]] is for the first data\n  #list[[1]] is a dataframe ,  df[1,'valuecode'] is the rowcode , df[2,'valuecode'] is the colcode\n  #now we create a dataframe\n  myret <- as.data.frame(matrix(rep(NA,rowNum*colNum),nrow = rowNum))\n  rownames(myret) <- rowCodes\n  colnames(myret) <- colCodes\n  dfdata <- ret[[2]][[1]]\n  for (k in seq(1,nrow(dfdata))) {\n    wddf <- dfdata[k,\"wds\"][[1]]\n    myret[wddf[rowWdIdx,'valuecode'],wddf[colWdIdx,'valuecode']] <- dfdata[k,'data'][1,'data']\n  }\n  rownames(myret) <- rowNames\n  colnames(myret) <- colNames\n  return(myret)\n}\n\n#' the data categories\n#'\n#' the sub data categories for the zbid category, dbcode need to be specified, where the dbcode can be fetched by function\n#' statscnDbs(). In the returned data frame, the column 'isParent' shows if each sub category is leap category or not\n#' @param zbid the father zb/category id , the root id is 'zb'\n#' @param dbcode which db will be queried\n#' @return the data frame with the sub zbs/categories , if the given zbid is not a Parent zb/category, null list is returned\n#' @importFrom httr POST\n#' @importFrom jsonlite fromJSON\n#' @export\n#' @examples\n#'  statscnQueryZb()\n#'  statscnQueryZb('A01',dbcode=\"hgnd\")\nstatscnQueryZb<-function(zbid = \"zb\",dbcode = \"hgnd\")\n{\n  curQuery <- list(id = zbid, dbcode = dbcode, wdcode = \"zb\", m = \"getTree\")\n  yy <- POST(statscnbase, body = curQuery, encode = \"form\")\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  jj <- fromJSON(content(yy, \"text\", encoding = \"utf-8\"))\n  return(jj)\n}\n#' the regions in db\n#'\n#' the available regions in the specified db, it is used for query the province, city and country code generally\n#' @param dbcode the dbcode should be some province db(fs*) , city db(cs*) or internaltional db(gj*)\n#' @return the data frame with all the available region codes and names in the db\n#' @importFrom jsonlite fromJSON\n#' @export\n#' @examples\n#'  statscnRegions('fsnd')\n#'  statscnRegions('csnd')\n#'  statscnRegions('gjnd')\nstatscnRegions<-function(dbcode='fsnd')\n{\n  curQuery<-list(\n    m = \"getOtherWds\",\n    dbcode = dbcode,\n    rowcode = \"zb\",\n    colcode = \"sj\",\n    wds = \"[]\",\n    #dfwds=\"[]\",\n    k1 = milSec()\n  )\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy,\"text\",encoding = \"utf-8\"))\n  regIndex <- which(ret[[2]]$wdcode == 'reg')\n  df <- ret[[2]][,'nodes'][[regIndex]]\n  df$sort <- NULL\n  colnames(df) <- c(\"regCode\",\"name\")\n  return(df)\n}\n#' query data in the statscn db\n#'\n#' the main function for querying the statscn database, it will retrieve the data from specified db and orginize the data in a data frame.\n#' @param zb the zb/category code to be queried\n#' @param dbcode the db code for querying\n#' @param rowcode rowcode in the returned data frame\n#' @param colcode colcode in the returned data frame\n#' @param moreWd more constraint on the data\n#'        where the name should be one of c(\"reg\",\"sj\") , which stand for region and sj/time.\n#'        the valuecode for reg should be the region code queried by statscnRegions()\n#'        the valuecode for sj should be like '2014' for *nd , '2014C' for *jd , '201405' for *yd.\n#'        Be noted that , the moreWd name should be different with either rowcode or colcode\n#' @importFrom httr GET\n#' @importFrom jsonlite fromJSON\n#' @return the data frame you are quering\n#' @export\n#' @examples\n#' df <- statscnQueryData('A0201', dbcode = 'hgnd')\n#' df <- statscnQueryData('A0201',dbcode = 'fsnd', rowcode = 'zb', colcode = 'sj',\n#'                     moreWd = list(name = 'reg', value = '110000'))\nstatscnQueryData <- function(zb = \"A0201\", dbcode = \"hgnd\", rowcode = 'zb', colcode = 'sj', moreWd = list(name = NA, value = NA))\n{\n  curQuery <- list(\n    m = \"QueryData\",\n    dbcode = dbcode,\n    rowcode = rowcode,\n    colcode = colcode,\n    wds = genDfwds(moreWd$name,moreWd$value),\n    dfwds = genDfwds(\"zb\",zb),\n    k1 = milSec()\n  )\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy,\"text\", encoding = \"utf-8\"))\n  return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))\n}\n#' fetch the lastN data\n#'\n#' fetch the lastN data for the latest query, only affect the number of rows in the returned data.\n#' This function can not be used alone , statscnQueryData() has to be called before this function\n#' @param n the number of rows to be fetched\n#' @return the last n rows data in the latest query\n#' @importFrom httr GET\n#' @importFrom jsonlite fromJSON\n#' @export\n#' @examples\n#' df=statscnQueryData('A0201',dbcode='hgnd')\n#' df2=statscnQueryLastN(20)\nstatscnQueryLastN<-function(n)\n{\n  wdcode <- \"sj\"\n  valuecode <- paste(\"LAST\",n,sep = \"\")\n  if( is.null(get('lastQuery', envir = rstatscnEnv)) ){\n    stop(\"please call a statscnQueryData for some data firstly\")\n  }\n  curQuery <- get('lastQuery', envir = rstatscnEnv)\n  if( curQuery$m==\"QueryData\" ) {\n    curQuery$dfwds <- genDfwds(wdcode,valuecode)\n  }\n  yy <- GET(statscnbase, query = curQuery)\n  assign('lastQuery', curQuery, envir = rstatscnEnv)\n  checkHttpStatus(yy)\n  ret <- fromJSON(content(yy, \"text\", encoding = \"utf-8\"))\n  return(dataJson2df(ret,curQuery$rowcode,curQuery$colcode))\n}\n\n#' statscnRowNamePrefix\n#'\n#' set the rowName prefix in the dataframe\n#'\n#' in case you encounter the following error:\n#'   Error in `row.names<-.data.frame`(`*tmp*`, value = value) :\n#'   duplicate 'row.names' are not allowed\n#' you need to call this function\n#'\n#' @param p , how to set the rowname prefix.\n#'     it is 'nrow' by default , and it is the only supported value currently\n#'     to unset the row name prefix, call this function with p=NULL\n#' @return no return\n#' @export\nstatscnRowNamePrefix <- function(p = \"nrow\")\n{\n  if (p != \"nrow\" && ! is.null(p)) {\n    stop(sprintf(\"the only supported prefix is 'nrow' or NULL \"))\n  }\n  assign('prefix', p, envir = rstatscnEnv)\n}\n\n",
    "created" : 1498729331974.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3967534791",
    "id" : "AA43F9D1",
    "lastKnownWriteTime" : 1498788702,
    "last_content_update" : 1498788702508,
    "path" : "~/GitHub/gfer/R/rstatscn.R",
    "project_path" : "R/rstatscn.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}