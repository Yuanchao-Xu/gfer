max(x)
d
getLim <- function(x, y, n = 0.75, xlablen = 4) {
xl <- (max(x) - min(x)) * 1.1
yl <- (max(y) - min(y)) * 1.1
if (yl < n * xl) {
ratio <- xl * n / yl
change <- 'y'
xlim <- c(min(x) - 0.5 * xl, max(x) + 0.5 * xl)
ylim <- ratio * c(min(y) - 0.5 * yl, max(y)  + 0.5 * yl)
} else if (yl >= n * xl) {
ratio <- yl / n / xl
change <- 'x'
d <- (xl*ratio - xl) / 2
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
ylim <- c(min(y) - 0.5 * yl, max(y) + 0.5)
}
res <- list()
res$lim <- c(xlim, ylim)
res$ratio <- ratio
res$change <- change
return(res)
}
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
xlim
ylim
(max(xlim) - min(xlim)) / (max(ylim) - min(ylim))
(max(ylim) - min(ylim)) /(max(xlim) - min(xlim))
getLim <- function(x, y, n = 0.75, xlablen = 4) {
xl <- (max(x) - min(x)) * 1.1
yl <- (max(y) - min(y)) * 1.1
if (yl < n * xl) {
ratio <- xl * n / yl
change <- 'y'
xlim <- c(min(x) - 0.5 * xl, max(x) + 0.5 * xl)
ylim <- ratio * c(min(y) - 0.5 * yl * n, max(y)  + 0.5 * yl * n)
} else if (yl >= n * xl) {
ratio <- yl / n / xl
change <- 'x'
d <- (xl*ratio - xl) / 2
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
ylim <- c(min(y) - 0.5 * yl * n, max(y) + 0.5 * n )
}
res <- list()
res$lim <- c(xlim, ylim)
res$ratio <- ratio
res$change <- change
return(res)
}
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
(max(ylim) - min(ylim)) /(max(xlim) - min(xlim))
debug(getLim)
adj <- getLim(data$x, data$y)
xl
yl
data$x
data <- GDPmix
adj <- getLim(data$x, data$y)
function(x, y, n = 0.75, xlablen = 4) {
xl <- (max(x) - min(x)) * 1.1
yl <- (max(y) - min(y)) * 1.1
if (yl < n * xl) {
ratio <- xl * n / yl
change <- 'y'
xlim <- c(min(x) - 0.5 * xl, max(x) + 0.5 * xl)
ylim <- ratio * c(min(y) - 0.5 * yl * n, max(y)  + 0.5 * yl * n)
} else if (yl >= n * xl) {
ratio <- yl / n / xl
change <- 'x'
d <- (xl*ratio - xl) / 2
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
ylim <- c(min(y) - 0.5 * yl * n, max(y) + 0.5 * n )
}
res <- list()
res$lim <- c(xlim, ylim)
res$ratio <- ratio
res$change <- change
return(res)
}
C
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
xlim
ylim
(max(ylim) - min(ylim)) /(max(xlim) - min(xlim))
adj <- getLim(data$x, data$y)
x
y
xl
yl
ratio
xlim
xl
xl * ratio
xlim[2] - xlim[1]
x <- data$label
data$x
x <- data$x
y <- data$y
xl <- (max(x) - min(x))
yl <- (max(y) - min(y))
ratio <- yl / n / xl
change <- 'x'
xl <- xl * ratio
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
ylim <- c(min(y) - 0.5 * yl * n, max(y) + 0.5 * n )
xlim
ylim
xl
x
ratio
c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
xl <- (max(x) - min(x))
xl
yl
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
xlim
min(x) * ratio
c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
xl
xlim
ylim <- c(min(y) - 0.5 * yl * n, max(y) + 0.5 * yl* n )
ylim
yl
min(y)
(ylim[2] - ylim[1]) / (xlim[2] - xlim[1])
xl
xlim[2] - xlim[1]
xl * ratio
ratio * c(min(x) , max(x))
a <- ratio * c(min(x) , max(x))
a[2] - a[1]
ad <- a[2] - a[1]
xd <- a[2] - a[1]
1.1 * xd
xlim <- ratio * c(min(x) - 0.5 * xl , max(x) + 0.5 * xl)
xlim[2] - xlim[1]
xlim <- ratio * c(min(x), max(x))
xlim
xlim[2] - xlim[1]
xl <- (max(x) - min(x))
yl <- (max(y) - min(y))
xl
yl
ratio <- yl / n / xl
change <- 'x'
xlim <- ratio * c(min(x), max(x))
ylim <- c(min(y), max(y))
xlim
ylim
xl
yl
(ylim[2] - ylim[1]) / (xlim[2] - xlim[1])
c(xlim[1] - 0.5 * xl, xlim[2] + 0.5 * xl)
c(ylim[1] - 0.5 * yl * n, ylim[2] + 0.5 * yl * n)
xlim1 <- c(xlim[1] - 0.5 * xl, xlim[2] + 0.5 * xl)
ylim1 <- c(ylim[1] - 0.5 * yl * n, ylim[2] + 0.5 * yl * n)
(ylim1[2] - ylim1[1]) / (xlim1[2] - xlim1[1])
ylim1[2]
0.5 * yl * n
ylim[1]
xl
xl <- xlim[2] - xlim[1]
yl <- ylim[2] - ylim[1]
xlim1 <- c(xlim[1] - 0.5 * xl, xlim[2] + 0.5 * xl)
ylim1 <- c(ylim[1] - 0.5 * yl * n, ylim[2] + 0.5 * yl * n)
(ylim1[2] - ylim1[1]) / (xlim1[2] - xlim1[1])
xd <- (xlim[2] - xlim[1]) * 0.1/2
yd <- (ylim[2] - ylim[1]) * 0.1/2
xd <- (xlim[2] - xlim[1]) * 0.1/2
yd <- (ylim[2] - ylim[1]) * 0.1/2
xlim1 <- c(xlim[1] - xd, xlim[2] + xd)
ylim1 <- c(ylim[1] - yd, ylim[2] + yd)
(ylim1[2] - ylim1[1]) / (xlim1[2] - xlim1[1])
getLim <- function(x, y, n = 0.75, xlablen = 4) {
xl <- (max(x) - min(x))
yl <- (max(y) - min(y))
if (yl < n * xl) {
ratio <- xl * n / yl
change <- 'y'
xlim <- c(min(x), max(x))
ylim <- ratio * c(min(y), max(y))
} else if (yl >= n * xl) {
ratio <- yl / n / xl
change <- 'x'
xlim <- ratio * c(min(x), max(x))
ylim <- c(min(y), max(y))
}
# enlarge xlim and ylim for elements not to reach the border
xd <- (xlim[2] - xlim[1]) * 0.1/2
yd <- (ylim[2] - ylim[1]) * 0.1/2
xlim <- c(xlim[1] - xd, xlim[2] + xd)
ylim <- c(ylim[1] - yd, ylim[2] + yd)
res <- list()
res$lim <- c(xlim, ylim)
res$ratio <- ratio
res$change <- change
return(res)
}
data$x
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
xlim
ylim
(ylim[2] - ylim[1]) / (xlim[2] - xlim[1])
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
xlabels
layer_plot
layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle()
library(ggplot2)
library(ggrepel)
library(scatterpie)
layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle()
layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() + xlim(xlim)
getLim <- function(x, y, n = 0.75, xlablen = 4) {
xl <- (max(x) - min(x))
yl <- (max(y) - min(y))
if (yl < n * xl) {
ratio <- xl * n / yl
change <- 'y'
xlim <- c(min(x), max(x))
ylim <- ratio * c(min(y), max(y))
} else if (yl >= n * xl) {
ratio <- yl / n / xl
change <- 'x'
xlim <- ratio * c(min(x), max(x))
ylim <- c(min(y), max(y))
}
# enlarge xlim and ylim for elements not to reach the border
xd <- (xlim[2] - xlim[1]) * 0.2/2
yd <- (ylim[2] - ylim[1]) * 0.2/2
xlim <- c(xlim[1] - xd, xlim[2] + xd)
ylim <- c(ylim[1] - yd, ylim[2] + yd)
res <- list()
res$lim <- c(xlim, ylim)
res$ratio <- ratio
res$change <- change
return(res)
}
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
data$x
data <- GDPmix
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle()
layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() + xlim(xlim)
plotScatterPie <- function(data, pieRange, pieColor = NULL, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL,
output = FALSE) {
## input check
if(is.null(pieRange)) stop("You have to assign which column to which column to be presented by pie chart.")
if(length(pieRange)!=length(pieColor)) stop("Length of pieRange and pieColor should be the same.")
# adjustment of x and y
# since coord_equal is set in order to make the pie chart round, and
# most of time y axis is tens times of x axis, the plot will be weird.
# So x and y axis must be adjusted to roughly 4:3, and add the label manually afterwards
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
if (adj$change == 'x') {
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
} else if (adj$change == 'y') {
xbreaks <- getLabels(c(min(data$x), max(data$x)), 4)
xlabels <- xbreaks
ylabels <- getLabels(c(min(data$y), max(data$y)), 3)
data$y <- data$y * ratio
ybreaks <- ylabels * ratio
}
with (data, {
layer_basic <- ggplot(data, aes(x = x))
#     geom_point(data = data, aes(x, y))
data$radius <- getRadius(data$r)
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[pieRange], color = 'white')
if (is.null(labelLine)) labelLine <- max(data$radius)/4
layer_label <- geom_text_repel(data = data, aes(x, y, label = label),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
if (xmeanLine == TRUE) layer_basic <- layer_basic + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_basic <- layer_basic + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
if (!is.null(pieColor)) layer_basic <- layer_basic + scale_fill_manual(values = pieColor)
layer_plot <- layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() +
scale_x_continuous(breaks = xbreaks, labels = xlabels, limits = xlim) +
scale_y_continuous(breaks = ybreaks, labels = ylabels)
print(layer_plot)
if (output == TRUE) return(layer_plot)
})
}
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
plotScatterPie <- function(data, pieRange, pieColor = NULL, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL,
output = FALSE) {
## input check
if(is.null(pieRange)) stop("You have to assign which column to which column to be presented by pie chart.")
if(length(pieRange)!=length(pieColor)) stop("Length of pieRange and pieColor should be the same.")
# adjustment of x and y
# since coord_equal is set in order to make the pie chart round, and
# most of time y axis is tens times of x axis, the plot will be weird.
# So x and y axis must be adjusted to roughly 4:3, and add the label manually afterwards
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
if (adj$change == 'x') {
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
} else if (adj$change == 'y') {
xbreaks <- getLabels(c(min(data$x), max(data$x)), 4)
xlabels <- xbreaks
ylabels <- getLabels(c(min(data$y), max(data$y)), 3)
data$y <- data$y * ratio
ybreaks <- ylabels * ratio
}
with (data, {
layer_basic <- ggplot(data, aes(x = x))
#     geom_point(data = data, aes(x, y))
data$radius <- getRadius(data$r)
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[pieRange], color = 'white')
if (is.null(labelLine)) labelLine <- max(data$radius)/5
layer_label <- geom_text_repel(data = data, aes(x, y, label = label),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
if (xmeanLine == TRUE) layer_basic <- layer_basic + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_basic <- layer_basic + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
if (!is.null(pieColor)) layer_basic <- layer_basic + scale_fill_manual(values = pieColor)
layer_plot <- layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() +
scale_x_continuous(breaks = xbreaks, labels = xlabels, limits = xlim) +
scale_y_continuous(breaks = ybreaks, labels = ylabels)
print(layer_plot)
if (output == TRUE) return(layer_plot)
})
}
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
plotScatterPie <- function(data, pieRange, pieColor = NULL, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL,
output = FALSE) {
## input check
if(is.null(pieRange)) stop("You have to assign which column to which column to be presented by pie chart.")
if(length(pieRange)!=length(pieColor)) stop("Length of pieRange and pieColor should be the same.")
# adjustment of x and y
# since coord_equal is set in order to make the pie chart round, and
# most of time y axis is tens times of x axis, the plot will be weird.
# So x and y axis must be adjusted to roughly 4:3, and add the label manually afterwards
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
if (adj$change == 'x') {
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
} else if (adj$change == 'y') {
xbreaks <- getLabels(c(min(data$x), max(data$x)), 4)
xlabels <- xbreaks
ylabels <- getLabels(c(min(data$y), max(data$y)), 3)
data$y <- data$y * ratio
ybreaks <- ylabels * ratio
}
with (data, {
layer_basic <- ggplot(data, aes(x = x))
#     geom_point(data = data, aes(x, y))
data$radius <- getRadius(data$r)
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[pieRange], color = 'white')
if (is.null(labelLine)) labelLine <- max(data$radius)/6
layer_label <- geom_text_repel(data = data, aes(x, y, label = label),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
if (xmeanLine == TRUE) layer_basic <- layer_basic + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_basic <- layer_basic + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
if (!is.null(pieColor)) layer_basic <- layer_basic + scale_fill_manual(values = pieColor)
layer_plot <- layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() +
scale_x_continuous(breaks = xbreaks, labels = xlabels, limits = xlim) +
scale_y_continuous(breaks = ybreaks, labels = ylabels)
print(layer_plot)
if (output == TRUE) return(layer_plot)
})
}
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
plotScatterPie <- function(data, pieRange, pieColor = NULL, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL,
output = FALSE) {
## input check
if(is.null(pieRange)) stop("You have to assign which column to which column to be presented by pie chart.")
if(length(pieRange)!=length(pieColor)) stop("Length of pieRange and pieColor should be the same.")
# adjustment of x and y
# since coord_equal is set in order to make the pie chart round, and
# most of time y axis is tens times of x axis, the plot will be weird.
# So x and y axis must be adjusted to roughly 4:3, and add the label manually afterwards
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
if (adj$change == 'x') {
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
} else if (adj$change == 'y') {
xbreaks <- getLabels(c(min(data$x), max(data$x)), 4)
xlabels <- xbreaks
ylabels <- getLabels(c(min(data$y), max(data$y)), 3)
data$y <- data$y * ratio
ybreaks <- ylabels * ratio
}
with (data, {
layer_basic <- ggplot(data, aes(x = x))
#     geom_point(data = data, aes(x, y))
data$radius <- getRadius(data$r)
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[pieRange], color = 'white')
if (is.null(labelLine)) labelLine <- max(data$radius)/7
layer_label <- geom_text_repel(data = data, aes(x, y, label = label),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
if (xmeanLine == TRUE) layer_basic <- layer_basic + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_basic <- layer_basic + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
if (!is.null(pieColor)) layer_basic <- layer_basic + scale_fill_manual(values = pieColor)
layer_plot <- layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() +
scale_x_continuous(breaks = xbreaks, labels = xlabels, limits = xlim) +
scale_y_continuous(breaks = ybreaks, labels = ylabels)
print(layer_plot)
if (output == TRUE) return(layer_plot)
})
}
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
plotScatterPie <- function(data, pieRange, pieColor = NULL, xmeanLine = TRUE, ymeanLine = TRUE, labelLine = NULL,
output = FALSE) {
## input check
if(is.null(pieRange)) stop("You have to assign which column to which column to be presented by pie chart.")
if(length(pieRange)!=length(pieColor)) stop("Length of pieRange and pieColor should be the same.")
# adjustment of x and y
# since coord_equal is set in order to make the pie chart round, and
# most of time y axis is tens times of x axis, the plot will be weird.
# So x and y axis must be adjusted to roughly 4:3, and add the label manually afterwards
adj <- getLim(data$x, data$y)
xlim <- adj$lim[1:2]
ylim <- adj$lim[3:4]
if (adj$change == 'x') {
xlabels <- getLabels(c(min(data$x), max(data$x)), 4)
data$x <- data$x * ratio
xbreaks <- xlabels * ratio
ybreaks <- getLabels(c(min(data$y), max(data$y)), 3)
ylabels <- ybreaks
} else if (adj$change == 'y') {
xbreaks <- getLabels(c(min(data$x), max(data$x)), 4)
xlabels <- xbreaks
ylabels <- getLabels(c(min(data$y), max(data$y)), 3)
data$y <- data$y * ratio
ybreaks <- ylabels * ratio
}
with (data, {
layer_basic <- ggplot(data, aes(x = x))
#     geom_point(data = data, aes(x, y))
data$radius <- getRadius(data$r)
layer_pie <- geom_scatterpie(data = data, aes(x, y, r = radius),
cols = colnames(data)[pieRange], color = 'white')
if (is.null(labelLine)) labelLine <- max(data$radius)/8
layer_label <- geom_text_repel(data = data, aes(x, y, label = label),
point.padding = unit(labelLine, "lines"))
#layer_legend <- geom_scatterpie_legend(data$radius, x= 0, y=0)
if (xmeanLine == TRUE) layer_basic <- layer_basic + geom_vline(xintercept = mean(data$x), color = 'red', size = 1.5, linetype = 2)
if (ymeanLine == TRUE) layer_basic <- layer_basic + geom_hline(yintercept = mean(data$y), color = 'red', size = 1.5, linetype = 2)
if (!is.null(pieColor)) layer_basic <- layer_basic + scale_fill_manual(values = pieColor)
layer_plot <- layer_basic + layer_pie + layer_label  +
coord_equal() + ggstyle() +
scale_x_continuous(breaks = xbreaks, labels = xlabels, limits = xlim) +
scale_y_continuous(breaks = ybreaks, labels = ylabels)
print(layer_plot)
if (output == TRUE) return(layer_plot)
})
}
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
devtools::check(cran = T)
devtools::check(cran = T)
GDPmix
colnames(GDPmix)
colnames(GDPmix)[1]
colnames(GDPmix)[1] <- 'Province'
colnames(GDPmix)[1]
colnames(GDPmix)
devtools::use_data(GDPmix, GDPmix)
colnames(GDPmix)[1] <- 'label'
plotScatterPie(GDPmix, pieRange = 4:6, pieColor = GDPColor_CWR)
devtools::check(cran = T)
rm(ls())
rm(list=ls())
